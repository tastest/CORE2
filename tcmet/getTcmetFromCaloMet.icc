// -*- C++ -*-

#ifndef GETTCMETFROMCALOMET_ICC
#define GETTCMETFROMCALOMET_ICC

#include "TH2.h"

using namespace std;
using namespace tas;

static metStruct getTcmetFromCaloMet(TH2F* rf, bool useElectronVetoCone = false, bool usePV = false, bool useHFcleaning = true, 
                                     bool useHCALcleaning = true, bool useECALcleaning = false, bool printout = false, ostream& ostr = cout);
static bool  isMuon               ( int index );
static bool  isElectron           ( int index );
static bool  isGoodTrack          ( int index, bool usePV = false );
static void  correctMETforMuon    ( LorentzVector p4, int index );
static void  correctMETforPion    ( int index , TH2F* rf);
static void  correctSumEtForMuon  ( LorentzVector p4, int index );
static void  correctSumEtForPion  ( int index , TH2F* rf);
static bool  closeToElectron      ( int index );

void printMet(string label, float tcmet_x_pre, float tcmet_y_pre, float tcmet_x , float tcmet_y , float tcsumet, ostream& ostr, int width = 12){
  
  ostr << "|" << setw(width) << label                               << setw(width)
       << "|" << setw(width) << tcmet_x - tcmet_x_pre               << setw(width)
       << "|" << setw(width) << tcmet_y - tcmet_y_pre               << setw(width)
       << "|" << setw(width) << tcmet_x                             << setw(width)
       << "|" << setw(width) << tcmet_y                             << setw(width)
       << "|" << setw(width) << sqrt(pow(tcmet_x,2)+pow(tcmet_y,2)) << setw(width)       
       << "|" << setw(width) << atan2(tcmet_y,tcmet_x)              << setw(width)       
       << "|" << setw(width) << tcsumet                             << setw(width) << "|" << endl;
  
}

void printHeader(ostream& ostr, int width = 12){

  ostr << endl;
  ostr << evt_dataset() << endl;
  ostr << evt_run() << " " << evt_lumiBlock() << " " << evt_event() << endl;

  ostr << "|" << setw(width) << "label"   << setw(width)
       << "|" << setw(width) << "deltax"  << setw(width)
       << "|" << setw(width) << "deltay"  << setw(width)
       << "|" << setw(width) << "metx"    << setw(width)
       << "|" << setw(width) << "mety"    << setw(width)
       << "|" << setw(width) << "met"     << setw(width)
       << "|" << setw(width) << "metphi"  << setw(width)
       << "|" << setw(width) << "sumet"   << setw(width) << "|" << endl;
    
}

//--------------------------------------------------------------------

#include "cleanTcmet.icc"

float tcmet_x;
float tcmet_y;
float tcmet_x_pre;
float tcmet_y_pre;
float tcsumet;
bool  printout_;

metStruct getTcmetFromCaloMet (TH2F* rf, bool useElectronVetoCone, bool usePV, bool useHFcleaning, bool useHCALcleaning, bool useECALcleaning, bool printout, ostream& ostr)
{

  printout_ = printout;

     //initialize to calomet values
     tcmet_x = evt_met() * cos( evt_metPhi() );
     tcmet_y = evt_met() * sin( evt_metPhi() );
     tcsumet = evt_sumet();
  
     if(printout_){
       printHeader(ostr);
       printMet("Initial",tcmet_x,tcmet_y,tcmet_x,tcmet_y,tcsumet,ostr);
     }

     //correct calomet for muons
     for( unsigned int i = 0; i < mus_p4().size(); i++ ) {
    
	  int flag = mus_tcmet_flag().at(i);
    
          tcmet_x_pre = tcmet_x;
          tcmet_y_pre = tcmet_y;

	  if( flag == 0 ) continue;
    
	  //for flags 1,2,3,5 only perform muon correction
	  //if validSTAHits > 0
         
	  else if( flag == 1 ) { 
      
	       if(mus_gfit_validSTAHits().at(i) > 0) {
		    correctMETforMuon  ( mus_gfit_p4().at(i), i );
		    correctSumEtForMuon( mus_gfit_p4().at(i), i );
                    if(printout_)       printMet("Muon",tcmet_x_pre,tcmet_y_pre,tcmet_x,tcmet_y,tcsumet,ostr);
	       }
      
	       else if(isGoodTrack( mus_trkidx().at(i), usePV)) {
		    correctMETforPion  ( mus_trkidx().at(i) , rf);
		    correctSumEtForPion( mus_trkidx().at(i) , rf);
                    if(printout_)       printMet("Pion",tcmet_x_pre,tcmet_y_pre,tcmet_x,tcmet_y,tcsumet,ostr);
	       }
	  }
	  else if( flag == 2 ) {
      
	       if(mus_gfit_validSTAHits().at(i) > 0) {
		    correctMETforMuon  ( mus_trk_p4().at(i), i );
		    correctSumEtForMuon( mus_trk_p4().at(i), i );
                    if(printout_)       printMet("Muon",tcmet_x_pre,tcmet_y_pre,tcmet_x,tcmet_y,tcsumet,ostr);
	       }
      
	       else if(isGoodTrack( mus_trkidx().at(i), usePV)) {
		    correctMETforPion  ( mus_trkidx().at(i) , rf);
		    correctSumEtForPion( mus_trkidx().at(i) , rf);
                    if(printout_)       printMet("Pion",tcmet_x_pre,tcmet_y_pre,tcmet_x,tcmet_y,tcsumet,ostr);
	       }
	  }
	  else if( flag == 3 || flag==5 ) {
      
	       if(mus_gfit_validSTAHits().at(i) > 0) {
		    correctMETforMuon  ( mus_p4().at(i), i );
		    correctSumEtForMuon( mus_p4().at(i), i );
                    if(printout_)       printMet("Muon",tcmet_x_pre,tcmet_y_pre,tcmet_x,tcmet_y,tcsumet,ostr);
	       }

	       else if(isGoodTrack( mus_trkidx().at(i), usePV)) {
		    correctMETforPion  ( mus_trkidx().at(i) , rf);
		    correctSumEtForPion( mus_trkidx().at(i) , rf);
                    if(printout_)       printMet("Pion",tcmet_x_pre,tcmet_y_pre,tcmet_x,tcmet_y,tcsumet,ostr);
	       }
	  }
	  else if( flag == 4 ) {
	       correctMETforPion  ( mus_trkidx().at(i) , rf);
	       correctSumEtForPion( mus_trkidx().at(i) , rf);
               if(printout_)       printMet("Pion",tcmet_x_pre,tcmet_y_pre,tcmet_x,tcmet_y,tcsumet,ostr);
               
	  }
    
	  else
	       std::cout << "Muon has an undefined flag!\n";
    
     }
  
     //correct muon-corrected calomet for pions
     for( unsigned int i = 0; i < trks_trk_p4().size(); i++ ) {
    
	  if( isMuon( i ) ) 
	       continue;
    
	  if( isElectron( i ) ) 
	       continue;
    
	  if( !isGoodTrack( i, usePV ) ) 
	       continue;

	  if (useElectronVetoCone && closeToElectron(i))
	       continue;

          tcmet_x_pre = tcmet_x;
          tcmet_y_pre = tcmet_y;
          
	  correctMETforPion( i , rf);
	  correctSumEtForPion( i , rf);
          
          if( printout_ ){
            if( closeToElectron(i) )  printMet("Pion (e)",tcmet_x_pre,tcmet_y_pre,tcmet_x,tcmet_y,tcsumet,ostr);
            else                      printMet("Pion",    tcmet_x_pre,tcmet_y_pre,tcmet_x,tcmet_y,tcsumet,ostr);
          }
     }
  
     float tcmet    = TMath::Sqrt( tcmet_x * tcmet_x + tcmet_y * tcmet_y );
     float tcmetPhi = atan2(tcmet_y,tcmet_x); 

     metStruct tcmetStruct;
     tcmetStruct.met    = tcmet;
     tcmetStruct.metphi = tcmetPhi;
     tcmetStruct.metx   = tcmet_x;
     tcmetStruct.mety   = tcmet_y;
     tcmetStruct.sumet  = tcsumet;

     if(printout_)       printMet("Pre clean",tcmet_x,tcmet_y,tcmet_x,tcmet_y,tcsumet,ostr);

     if (useHFcleaning){
       tcmet_x_pre = tcmet_x;
       tcmet_y_pre = tcmet_y;
       tcmetStruct = cleanTCMETforHFspikes(tcmetStruct.metx, tcmetStruct.mety, tcmetStruct.sumet);
       if(printout_)       printMet("HF clean",tcmet_x_pre,tcmet_y_pre,tcmet_x,tcmet_y,tcsumet,ostr);
     }
     
     if (useHCALcleaning){
       tcmet_x_pre = tcmet_x;
       tcmet_y_pre = tcmet_y;
       tcmetStruct = cleanTCMETforHCALnoise(tcmetStruct.metx, tcmetStruct.mety, tcmetStruct.sumet);
       if(printout_)       printMet("HCAL clean",tcmet_x_pre,tcmet_y_pre,tcmet_x,tcmet_y,tcsumet,ostr);
     }

     if (useECALcleaning){
       tcmet_x_pre = tcmet_x;
       tcmet_y_pre = tcmet_y;
       tcmetStruct = cleanTCMETforECALspikes(tcmetStruct.metx, tcmetStruct.mety, tcmetStruct.sumet);
       if(printout_)       printMet("ECAL clean",tcmet_x_pre,tcmet_y_pre,tcmet_x,tcmet_y,tcsumet,ostr);
     }

     if(printout_)       printMet("Final",tcmet_x,tcmet_y,tcmet_x,tcmet_y,tcsumet,ostr);
     
     return tcmetStruct;
}

//--------------------------------------------------------------------

bool isGoodTrack( int index, bool usePV ) {
  
     float corrected_d0 = trks_d0corr().at(index);

     if(usePV)
	  corrected_d0 = trks_d0vtx().at(index);

     if( trks_algo().at(index) < 8 ) {

	  float d0cut = min( sqrt( pow(0.015,2) + pow(0.5/trks_trk_p4().at(index).pt(),2) ), 0.3);

	  if( corrected_d0 > d0cut ) return false;
     }
     else {
	  if( trks_validHits().at(index) < 11 )                              return false;
	  if( trks_chi2().at(index) / trks_ndof().at(index) > 3 )            return false;
	  if( trks_ptErr().at(index) / trks_trk_p4().at(index).pt() > 0.10 ) return false;
     }

     if( trks_trk_p4().at(index).pt() > 100 )                           return false;
     if( fabs( trks_trk_p4().at(index).eta() ) > 2.65 )                 return false;
     if( trks_validHits().at(index) < 6 )                               return false;
     if( trks_chi2().at(index) / trks_ndof().at(index) > 5 )            return false;
     if( trks_ptErr().at(index) / trks_trk_p4().at(index).pt() > 0.20 ) return false;
     if( !isTrackQuality( index, (1 << highPurity) ) )                  return false;
  
     return true;
}

//--------------------------------------------------------------------

void correctMETforMuon( LorentzVector p4, int index ) {

     float deltax = mus_met_deltax().at(index);
     float deltay = mus_met_deltay().at(index);

     tcmet_x -= ( p4.px() - deltax );
     tcmet_y -= ( p4.py() - deltay );

}

//--------------------------------------------------------------------

void correctMETforPion( int index , TH2F* rf) {

     float deltax = 0;
     float deltay = 0;
  
     if( trks_trk_p4().at(index).pt() > 1 ) {
    
	  int bin =        rf->FindBin(trks_trk_p4().at(index).eta(), trks_trk_p4().at(index).pt() );
	  float response = rf->GetBinContent( bin );
    
	  deltax = response * trks_trk_p4().at(index).P() * 
	       sin( trks_outer_p4().at(index).Theta() ) * cos( trks_outer_p4().at(index).phi() );
	  deltay = response * trks_trk_p4().at(index).P() * 
	       sin( trks_outer_p4().at(index).Theta() ) * sin( trks_outer_p4().at(index).phi() );
     }
  
     tcmet_x -= ( trks_trk_p4().at(index).px() - deltax );
     tcmet_y -= ( trks_trk_p4().at(index).py() - deltay );
}

//--------------------------------------------------------------------

void correctSumEtForMuon( LorentzVector p4, int index ){
  
     float deltax = mus_met_deltax().at(index);
     float deltay = mus_met_deltay().at(index);

     tcsumet += ( p4.pt() - TMath::Sqrt( deltax * deltax + deltay * deltay ) );
}

//--------------------------------------------------------------------

void correctSumEtForPion( int index , TH2F* rf) {
  
     if( trks_trk_p4().at(index).pt() < 1) {
	  tcsumet += trks_trk_p4().at(index).pt();
     }
  
     else {
	  int bin = rf->FindBin( trks_trk_p4().at(index).eta() , trks_trk_p4().at(index).pt()); 
	  double fracTrackEnergy = rf->GetBinContent( bin); 
	  tcsumet += ( 1 - fracTrackEnergy ) * trks_trk_p4().at(index).pt();
     }
}

//--------------------------------------------------------------------

bool isMuon( int index ) {

     for( unsigned int i = 0; i < mus_p4().size(); i++ ) {

	  if( mus_trkidx().at(i) == index ) return true;
     }

     return false;
}

//--------------------------------------------------------------------

bool isElectron( int index ) {

     for( unsigned int i = 0; i < els_p4().size(); i++ ) {

	  if( els_trkidx().at(i) == index && els_hOverE().at(i) < 0.1 ) return true;
     }

     return false;
}

//--------------------------------------------------------------------

bool closeToElectron( int index ) {

     for (unsigned int i = 0; i < els_p4().size(); i++)
     {
	  if (els_hOverE().at(i) > 0.1)
	       continue;

	  if (els_p4()[i].pt() < 10.)
	       continue;

	  float deltaPhi   = fabs( els_p4()[i].phi() - trks_trk_p4()[index].phi() );
          if( deltaPhi > TMath::Pi() ) deltaPhi = TMath::TwoPi() - deltaPhi;

	  float deltaEta   = els_p4()[i].eta() - trks_trk_p4()[index].eta();

	  float deltaR     = sqrt(deltaPhi * deltaPhi + deltaEta * deltaEta);

	  if (deltaR < 0.015)     return true;
     }

     return false;
}

//--------------------------------------------------------------------

#endif



