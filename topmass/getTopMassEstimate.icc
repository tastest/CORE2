// -*- C++ -*-

#ifndef GETTOPMASSESTIMATE_ICC
#define GETTOPMASSESTIMATE_ICC

#include "TH2.h"

using namespace std;
using namespace tas;

static float getTopMassEstimate(ttdilepsolve * d_llsol, int hypIdx, vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > &myJets_p4, double met, double metphi);

float getTopMassEstimate (ttdilepsolve * d_llsol, int hypIdx, vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > &myJets_p4, double met, double metphi)
{

  //top mass instanciation:
  // ttdilepsolve * d_llsol = new ttdilepsolve;
  // set up histos used in tomass calc
  TH1F * h_temp_MassWeight   = new TH1F("h_temp_MassWeight","h_temp_MassWeight", d_llsol->get_nMassPts(), d_llsol->get_RangeLow(), d_llsol->get_RangeHigh());
  TH1F * h_temp_MassWeight_1 = new TH1F("h_temp_MassWeight_1","h_temp_MassWeight_1", d_llsol->get_nMassPts(), d_llsol->get_RangeLow(), d_llsol->get_RangeHigh());
  TH1F * h_temp_MassWeight_2 = new TH1F("h_temp_MassWeight_2","h_temp_MassWeight_2", d_llsol->get_nMassPts(), d_llsol->get_RangeLow(), d_llsol->get_RangeHigh());
  float high_weight_mass;


  //101026 work begin
  // IBL: here the loop STARTs
  // -----------------------------------------
  // Start initialising variables for top mass
  // calculation: 
  // -----------------------------------------
  vector < TLorentzVector > nu1;
  vector < TLorentzVector > nu2;
  TLorentzVector lvTop1;
  TLorentzVector lvTop2;
        
  // hyp_lt_id()[hypIdx] * hyp_ll_id()[hypIdx] //OS
  TLorentzVector lepPlus;
  TLorentzVector lepMinus;
  if( hyp_lt_id()[hypIdx] < 0 ) {
    lepPlus.SetXYZT(
                    hyp_lt_p4()[hypIdx].x(),
                    hyp_lt_p4()[hypIdx].y(),
                    hyp_lt_p4()[hypIdx].z(),
                    hyp_lt_p4()[hypIdx].t()
                    );
          
    lepMinus.SetXYZT(
                     hyp_ll_p4()[hypIdx].x(),
                     hyp_ll_p4()[hypIdx].y(),
                     hyp_ll_p4()[hypIdx].z(),
                     hyp_ll_p4()[hypIdx].t()
                     );
  }
  else {
    lepPlus.SetXYZT(
                    hyp_ll_p4()[hypIdx].x(),
                    hyp_ll_p4()[hypIdx].y(),
                    hyp_ll_p4()[hypIdx].z(),
                    hyp_ll_p4()[hypIdx].t()
                    );
          
    lepMinus.SetXYZT(
                     hyp_lt_p4()[hypIdx].x(),
                     hyp_lt_p4()[hypIdx].y(),
                     hyp_lt_p4()[hypIdx].z(),
                     hyp_lt_p4()[hypIdx].t()
                     );
  }
        
  TVector2 tcmetVec;
  tcmetVec.SetMagPhi(met,metphi); 
  map<double, double >  mapJetPhi2Discr;
        
  h_temp_MassWeight   ->Reset();
  h_temp_MassWeight_1 ->Reset();
  h_temp_MassWeight_2 ->Reset();
        
  float max_weight_all = 0.;
  double max_sum_weight_all = 0.;
  unsigned int msw_jet_all1 = d_llsol->get_SENTINEL();
  unsigned int msw_jet_all2 = d_llsol->get_SENTINEL();
        
  unsigned int nSearchJets = myJets_p4.size();
  if (nSearchJets > 2) nSearchJets = 2;
        
        
  for (int i_t = 0; i_t < d_llsol->get_nMassPts(); i_t++){
    double m_top_iter = d_llsol->get_RangeLow() + i_t;  
          
    double max_sum_weight = 0.;
    unsigned int msw_jet1 = d_llsol->get_SENTINEL();
    unsigned int msw_jet2 = d_llsol->get_SENTINEL();
          
    for (unsigned int i_jet1 = 0; i_jet1 < nSearchJets; i_jet1++){
      for (unsigned int i_jet2 = i_jet1 + 1; i_jet2 < nSearchJets; i_jet2++){
              
        TLorentzVector jet1(
                            myJets_p4.at(i_jet1).x(),
                            myJets_p4.at(i_jet1).y(),
                            myJets_p4.at(i_jet1).z(),
                            myJets_p4.at(i_jet1).t()
                            );
        TLorentzVector jet2(
                            myJets_p4.at(i_jet2).x(),
                            myJets_p4.at(i_jet2).y(),
                            myJets_p4.at(i_jet2).z(),
                            myJets_p4.at(i_jet2).t()
                            );
              
        double sum_weight = 0;
        double h_weight = 0;
              
        double sum_weight_1 = 0;
              
        //Clear neutrino vectors and solve
        nu1.clear();
        nu2.clear();
        d_llsol->solve( tcmetVec , jet1 , jet2 , lepPlus, lepMinus, d_llsol->get_m_W() , d_llsol->get_m_W() , m_top_iter , m_top_iter  , nu1 , nu2 );
            
        for (int ui = 0; ui < nu1.size(); ui++){
          double s_weight = d_llsol->get_weight(jet1 , jet2, lepPlus, lepMinus, nu1[ui], nu2[ui], m_top_iter, mapJetPhi2Discr);
          sum_weight += s_weight;
          sum_weight_1 += s_weight;
          if (h_weight < s_weight) h_weight = s_weight;
          if (max_weight_all < s_weight){
            max_weight_all = s_weight;
            lvTop1 = lepPlus + nu1[ui] + jet1;
            lvTop2 = lepMinus + nu2[ui] + jet2;
          }
        }
              
        h_temp_MassWeight_1->Fill(m_top_iter, sum_weight_1);
              
        double sum_weight_2 = 0;
              
        //Clear neutrino vectors and solve
        nu1.clear();
        nu2.clear();
        d_llsol->solve( tcmetVec , jet2 , jet1 , lepPlus, lepMinus, d_llsol->get_m_W() , d_llsol->get_m_W(), m_top_iter , m_top_iter, nu1 , nu2 );
              
        for (int ui = 0; ui < nu1.size(); ui++){
          double s_weight = d_llsol->get_weight(jet2 , jet1, lepPlus, lepMinus, nu1[ui], nu2[ui], m_top_iter, mapJetPhi2Discr);
          sum_weight += s_weight;
          sum_weight_2 += s_weight;
          if (h_weight < s_weight) h_weight = s_weight;
          if (max_weight_all < s_weight){
            max_weight_all = s_weight;
            lvTop1 = lepPlus + nu1[ui] + jet2;
            lvTop2 = lepMinus + nu2[ui] + jet1;
          }
        }
              
        h_temp_MassWeight_2->Fill(m_top_iter, sum_weight_2);
              
        h_temp_MassWeight->Fill(m_top_iter, sum_weight);
              
        if (sum_weight > max_sum_weight){
          max_sum_weight = sum_weight;
          msw_jet1 = i_jet1;
          msw_jet2 = i_jet2;
        }
      }        //End loop over jet2
    }          //End loop over jet1
    if (max_sum_weight > max_sum_weight_all){
      max_sum_weight_all = max_sum_weight;
      msw_jet_all1 = msw_jet1;
      msw_jet_all2 = msw_jet2;
    }		
  }
  //Check if the highest weight is not zero
  float highestWeightCheck = h_temp_MassWeight->GetBinContent(h_temp_MassWeight->GetMaximumBin());
  if ( highestWeightCheck != 0 ){
          
    float high_weight_mass_1 = h_temp_MassWeight_1->GetMaximumBin() + d_llsol->get_RangeLow() - 1;
    float high_weight_mass_2 = h_temp_MassWeight_2->GetMaximumBin() + d_llsol->get_RangeLow() - 1;
          
    float hwm_weight_1 = h_temp_MassWeight_1->GetBinContent(h_temp_MassWeight_1->GetMaximumBin());
    float hwm_weight_2 = h_temp_MassWeight_2->GetBinContent(h_temp_MassWeight_2->GetMaximumBin());
          
    //          h_tree_MassWeight = h_temp_MassWeight;
    high_weight_mass  = h_temp_MassWeight->GetMaximumBin() + d_llsol->get_RangeLow() - 1;
          
    //    if (42 == 42) cout<<"Found dilepton ttbar candidate with Mtop = "<<high_weight_mass<<" GeV"<<endl<<endl;
  }
  //101026 work end

  delete h_temp_MassWeight  ;
  delete h_temp_MassWeight_1;
  delete h_temp_MassWeight_2;

  if(highestWeightCheck != 0) {
    return high_weight_mass;
  }
  // fallback return value
  return -999.;
}


#endif




